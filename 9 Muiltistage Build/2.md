# Multistage Build na Pr√°tica
Nesta se√ß√£o, vamos construir um exemplo pr√°tico de **Multistage Build** para uma aplica√ß√£o **Node.js** simples. Vamos incluir as etapas de desenvolvimento, teste, build, e produ√ß√£o para criar uma imagem Docker otimizada.

# 1. Estrutura do Projeto
go
```
multistage-app/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ package-lock.json
‚îî‚îÄ‚îÄ Dockerfile
```
## 1.1 C√≥digo da Aplica√ß√£o
### src/app.js:

javascript
```
const express = require('express');
const path = require('path');
const app = express();
const port = 3000;

app.use(express.static(path.join(__dirname, 'public')));

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.listen(port, () => {
    console.log(`App rodando em http://localhost:${port}`);
});
```
### src/index.html:

html
```
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Multistage Build</title>
</head>
<body>
    <h1>Ol√°, Multistage Build!</h1>
</body>
</html>
```
### package.json:

json
```
{
  "name": "multistage-app",
  "version": "1.0.0",
  "description": "Exemplo de Multistage Build",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "build": "echo 'Construindo projeto...'",
    "test": "echo 'Executando testes...' && exit 0"
  },
  "dependencies": {
    "express": "^4.18.2"
  }
}
```
# 2. Criando o Dockerfile com Multistage Build
## 2.1 Dockerfile
dockerfile
```
# Etapa 1: Build
FROM node:16 AS build
WORKDIR /app

# Copiar arquivos necess√°rios para o build
COPY package*.json ./
RUN npm install

# Copiar o restante do c√≥digo e executar o build
COPY . .
RUN npm run build

# Etapa 2: Testes
FROM build AS test
WORKDIR /app
RUN npm run test

# Etapa 3: Produ√ß√£o
FROM node:16-alpine AS production
WORKDIR /app

# Copiar apenas os arquivos necess√°rios para produ√ß√£o
COPY --from=build /app/src /app/src
COPY package*.json ./
RUN npm install --production

# Expor a porta e definir o comando padr√£o
EXPOSE 3000
CMD ["npm", "start"]
```
# 3. Explicando Cada Etapa
1. **Etapa de Build (`build`)**:
- Instala as depend√™ncias.
- Executa o build do projeto.
- Gera os artefatos necess√°rios para execu√ß√£o.

2. **Etapa de Testes (`test`)**:
- Executa testes (neste exemplo, √© apenas um placeholder para testes reais).

3. **Etapa de Produ√ß√£o (`production`)**:
- Usa uma imagem leve (`node:16-alpine`).
- Copia apenas os arquivos necess√°rios do est√°gio de build.

# 4. Construindo e Testando o Dockerfile
## 4.1 Construir a Imagem
Execute o comando abaixo no diret√≥rio do projeto:

bash
```
docker build -t multistage-app:1.0 .
```
### Sa√≠da esperada:
- A etapa de build instala depend√™ncias e cria os artefatos.
- A etapa de teste executa o comando de testes.
- A etapa de produ√ß√£o gera a imagem final.

## 4.2 Executar o Cont√™iner
Inicie o cont√™iner usando a imagem criada:

bash
```
docker run -d -p 3000:3000 --name multistage-app multistage-app:1.0
```
# 4.3 Testar a Aplica√ß√£o
Abra no navegador ou use o comando `curl` para verificar:

- URL: http://localhost:3000
- Comando curl:

bash
```
curl http://localhost:3000
```
### Sa√≠da esperada:

html
```
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Multistage Build</title>
</head>
<body>
    <h1>Ol√°, Multistage Build!</h1>
</body>
</html>
```
# 5. Otimiza√ß√µes Adicionais
## 5.1 Limpeza de Depend√™ncias
Na etapa de produ√ß√£o, instale apenas as depend√™ncias necess√°rias para execu√ß√£o:

dockerfile
```
RUN npm install --production
```
## 5.2 Uso de .dockerignore
Crie um arquivo `.dockerignore` para excluir arquivos desnecess√°rios do contexto de build:

**.dockerignore**:

bash
```
node_modules
*.log
.git
Dockerfile
.dockerignore
```
## 5.3 Verifique o Tamanho da Imagem
Use o comando `docker images` para verificar o tamanho final da imagem.

bash
```
docker images multistage-app
```
### Sa√≠da esperada:
- A imagem final ser√° significativamente menor devido ao uso do Multistage Build.

# 6. Conclus√£o
O **Multistage Build** permite criar imagens Docker otimizadas e bem estruturadas. Ele separa claramente as etapas de build, teste e produ√ß√£o, garantindo imagens menores, mais seguras e eficientes.

## Resumo de Benef√≠cios:
1. **Imagens Otimizadas**:
- Apenas os arquivos necess√°rios s√£o inclu√≠dos.
2. **Separa√ß√£o de Responsabilidades**:
- Cada etapa do processo tem um prop√≥sito claro.
3. **Redu√ß√£o de Tamanho e Complexidade**:
- Imagens menores e mais r√°pidas para distribuir.

Se precisar de ajuda para implementar o Multistage Build em seu projeto, √© s√≥ chamar! üöÄüòä