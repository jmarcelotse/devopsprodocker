# Usar um Est√°gio de Build como Base no Multistage Build
No Docker, voc√™ pode usar um est√°gio de build como base para outros est√°gios, permitindo compartilhar artefatos e configur√°-los de maneira eficiente. Isso √© √∫til em casos onde v√°rias imagens finais precisam usar o mesmo processo de constru√ß√£o, evitando redund√¢ncias e otimizando o build.

# 1. Por Que Usar Um Est√°gio de Build Como Base?
1. **Reutiliza√ß√£o de Artefatos**:
- Evita duplica√ß√£o ao compartilhar os mesmos artefatos entre diferentes est√°gios ou imagens finais.

2. **Consist√™ncia**:
- Todos os est√°gios dependem do mesmo processo de build, garantindo que as imagens finais estejam alinhadas.

3. **Efici√™ncia**:
- Reduz o tempo de build e o tamanho das imagens finais.

3. **Flexibilidade**:
- Permite criar m√∫ltiplas varia√ß√µes de imagens finais (exemplo: ambiente de produ√ß√£o e testes) a partir de um √∫nico build.

# 2. Exemplo Pr√°tico: Reutilizando Um Est√°gio de Build
Vamos usar uma aplica√ß√£o simples em **Node.js** para demonstrar como reutilizar o est√°gio de build em diferentes contextos (produ√ß√£o e desenvolvimento).

## 2.1 Estrutura do Projeto
go
```
shared-build/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ package-lock.json
‚îî‚îÄ‚îÄ Dockerfile
```
### src/app.js:

javascript
```
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.get('/', (req, res) => {
    res.send('<h1>Ol√°, Multistage Build Compartilhado!</h1>');
});

app.listen(port, () => {
    console.log(`Servidor rodando na porta ${port}`);
});
```
### package.json:

json
```
{
  "name": "shared-build",
  "version": "1.0.0",
  "description": "Exemplo de est√°gio compartilhado",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "test": "echo 'Nenhum teste implementado ainda!' && exit 0"
  },
  "dependencies": {
    "express": "^4.18.2"
  }
}
```
## 2.2 Dockerfile
Aqui, criamos um **est√°gio de build** compartilhado que ser√° usado como base para os est√°gios de desenvolvimento e produ√ß√£o.

dockerfile
```
# Etapa de Build Compartilhada
FROM node:16 AS build
WORKDIR /app

# Instalar depend√™ncias
COPY package.json package-lock.json ./
RUN npm install

# Copiar o c√≥digo-fonte
COPY . .

# Etapa para Desenvolvimento
FROM build AS dev
CMD ["npm", "start"]

# Etapa para Produ√ß√£o
FROM node:16-alpine AS prod
WORKDIR /app

# Copiar artefatos do est√°gio de build
COPY --from=build /app /app

# Apenas instalar depend√™ncias de produ√ß√£o
RUN npm install --production

# Expor porta e definir comando padr√£o
EXPOSE 3000
CMD ["npm", "start"]
```
## 2.3 Explica√ß√£o do Dockerfile
1. **Est√°gio de Build (`build`)**:
- Respons√°vel por instalar depend√™ncias e preparar os artefatos.
- Serve como base para os outros est√°gios.

2. **Est√°gio de Desenvolvimento (`dev`)**:
- Usa o est√°gio build como base.
- Inclui todas as depend√™ncias (inclusive dev).

3. **Est√°gio de Produ√ß√£o (`prod`)**:
- Usa apenas os artefatos necess√°rios do est√°gio `build`.
- Instala apenas as depend√™ncias de produ√ß√£o.

# 3. Construindo e Usando os Est√°gios
## 3.1 Construir Imagem de Desenvolvimento
bash
```
docker build --target dev -t shared-build:dev .
```
### Resultado:
- Cria uma imagem para desenvolvimento com todas as depend√™ncias.

### Executar o Cont√™iner:

bash
```
docker run -d -p 3000:3000 shared-build:dev
```
## 3.3 Construir Todas as Imagens
Se n√£o especificar um `--target`, o Docker executar√° todas as etapas e criar√° a imagem final do √∫ltimo est√°gio:

bash
```
docker build -t shared-build:latest .
```
# 4. Boas Pr√°ticas ao Compartilhar Est√°gios
## 4.1 Nomeie Est√°gios Descritivamente
Use nomes significativos para os est√°gios:

dockerfile
```
FROM node:16 AS build-stage
FROM build-stage AS dev-stage
FROM node:16-alpine AS prod-stage
```
## 4.2 Use `.dockerignore`
Reduza o contexto de build com um arquivo `.dockerignore`:

plaintext
```
node_modules
*.log
.git
Dockerfile
.dockerignore
```
## 4.3 Limpe Depend√™ncias
Certifique-se de instalar apenas o necess√°rio para cada est√°gio:
- Para produ√ß√£o:

dockerfile
```
RUN npm install --production
```
## 4.4 Combine com --target para Depura√ß√£o
Durante o desenvolvimento, construa apenas os est√°gios necess√°rios:

bash
```
docker build --target build -t debug-build .
```
# 5. Cen√°rios Comuns para Est√°gios Compartilhados
1. **V√°rios Ambientes**:
- Use a mesma base para imagens de produ√ß√£o, desenvolvimento e testes.

2. **Imagens Personalizadas**:
- Crie variantes espec√≠ficas (como vers√µes leves ou otimizadas).

3. **Reutiliza√ß√£o em Pipelines CI/CD**:
- Execute apenas at√© o est√°gio necess√°rio para validar builds e testes.

# 6. Conclus√£o
Reutilizar um est√°gio de build como base em **Multistage Builds** √© uma pr√°tica poderosa para criar imagens consistentes e eficientes. Isso simplifica o gerenciamento de depend√™ncias, otimiza o build e reduz o tempo de desenvolvimento.

## Resumo de Benef√≠cios:
- Redu√ß√£o de duplica√ß√£o no Dockerfile.
- Maior consist√™ncia entre diferentes imagens.
- Facilita a cria√ß√£o de varia√ß√µes espec√≠ficas (desenvolvimento, produ√ß√£o, testes).

Se precisar de ajuda para configurar ou ajustar Multistage Builds com est√°gios compartilhados, √© s√≥ chamar! üöÄüòä